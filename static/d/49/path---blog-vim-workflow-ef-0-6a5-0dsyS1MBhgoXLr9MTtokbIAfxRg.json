{"data":{"site":{"siteMetadata":{"title":"David Bernheisel","author":"David Bernheisel"}},"markdownRemark":{"id":"de95679a-bff6-51f7-9cd3-bc06a45f0594","excerpt":"I love my VIM workflow, so I want to share that with you. I am by-no-means a VIM\nexpert or purist â€” my neovim files are not slim and are aâ€¦","timeToRead":6,"html":"<p>I love my VIM workflow, so I want to share that with you. I am by-no-means a VIM\nexpert or purist â€” my <a href=\"https://neovim.io\">neovim</a> files are not slim and are a melting pot of\nstolen code from others, sometimes modified or not; sometimes found in GitHub\ncomments, sometimes found in othersâ€™ dotfiles, or Reddit comments.</p>\n<p>If you develop in Ruby or Elixir or write Markdown, you might find this helpful.</p>\n<p>Letâ€™s start with some basics:</p>\n<h2>Environment</h2>\n<ul>\n<li><a href=\"https://neovim.io\">neovim</a> - right now Iâ€™m using 0.4.0 so I can use floating windows.</li>\n<li><a href=\"https://sw.kovidgoyal.net/kitty/\">kitty</a> Terminal Emulator</li>\n<li>built-in terminal in neovim</li>\n<li><a href=\"https://www.archlinux.org\">ArchLinux</a> - My distro of choice. Shouldnâ€™t matter for this article.</li>\n<li><a href=\"https://github.com/Airblader/i3\">i3</a> - My window manager. Shouldnâ€™t matter for this article.</li>\n<li><a href=\"https://github.com/junegunn/vim-plug\">Plug</a> - for managing neovim plugins.</li>\n</ul>\n<p>There are three ways that I can split my workspace: (1) via my window manager\n<a href=\"https://github.com/Airblader/i3\">i3</a>, (2) via my terminal emulator <a href=\"https://sw.kovidgoyal.net/kitty/\">kitty</a>, (3) via <a href=\"https://neovim.io\">neovim</a> with\nsplits/buffers. Generally I adhere to this practice:</p>\n<ol>\n<li>Split with i3 if itâ€™s an application, especially a GUI app. This gives me\nthe ability to move the window to another desktop if I want.</li>\n<li>Split with built-in neovim terminal for tests.</li>\n<li>Donâ€™t split with kitty ever. Itâ€™d be too confusing for me to have 3 sets of\nkeyboard shortcuts to keep track of for switching windows/panes/splits.\nMaybe one day Iâ€™ll replace the built-in neovim terminal with a kitty split\nor an i3 split.</li>\n</ol>\n<h2>Testing</h2>\n<p>I use <a href=\"https://github.com/janko/vim-test\">vim-test</a> and itâ€™s pretty incredible. I picked this workflow up while\nworking at thoughtbot from some good friends and the <a href=\"https://github.com/thoughtbot/dotfiles\">thoughtbot dotfiles</a>,\nand it changed the way I code. The whole TDD workflow is great despite that I\nstill have trouble actually writing tests first - I tend to spike, iterate,\niterate, THEN write tests, then open a PR. Yeaâ€” this probably means Iâ€™m not a\n10x developer ðŸ˜›</p>\n<p>I use <a href=\"https://github.com/kassio/neoterm\">neoterm</a> to help open up terminal splits while coding. When Iâ€™m at home,\nI have an ultrawide that I use so splitting windows vertically is the way to go;\nbut when Iâ€™m mobile with my laptop then I typically split horizontally. I want\ntests to be visible either way, so I want this to be flexible.</p>\n<p>The vim-test neoterm strategy defaults to sending tests to the last-used neoterm\nbuffer; I can have more terminal buffers, but the first one I open is what\nvim-test will use going forward.</p>\n<p>Hereâ€™s how I configure vim-test with neoterm.</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">&quot; ~/.config/nvim/init.vim\n\n&quot; Test\nlet g:test#strategy = &quot;neoterm&quot;\nlet g:neoterm_shell = &#39;$SHELL -l&#39; &quot; use the login shell\nlet g:neoterm_default_mod = &#39;vert&#39;\nlet g:neoterm_autoscroll = 1      &quot; autoscroll to the bottom when entering insert mode\nlet g:neoterm_size = 80\nlet g:neoterm_fixedsize = 1       &quot; fixed size. The autosizing was wonky for me\nlet g:neoterm_keep_term_open = 0  &quot; when buffer closes, exit the terminal too.\n\n&quot; Create some commands that makes the splits easy\n\nfunction! OpenTermV(...)\n  let g:neoterm_size = 80\n  let l:cmd = a:1 == &#39;&#39; ? &#39;pwd&#39; : a:1\n  execute &#39;vert T &#39;.l:cmd\nendfunction\n\nfunction! OpenTermH(...)\n  let g:neoterm_size = 10\n  let l:cmd = a:1 == &#39;&#39; ? &#39;pwd&#39; : a:1\n  execute &#39;belowright T &#39;.l:cmd\nendfunction\n\ncommand! -nargs=? VT call OpenTermV(&lt;q-args&gt;)\ncommand! -nargs=? HT call OpenTermH(&lt;q-args&gt;)\n\nfunction! RunTestSuite()\n  Tclear\n  if filereadable(&#39;bin/test_suite&#39;)\n    T echo &#39;bin/test_suite&#39;\n    T bin/test_suite\n  elseif filereadable(&quot;bin/test&quot;)\n    T echo &#39;bin/test&#39;\n    T bin/test\n  else\n    TestSuite\n  endif\nendfunction\n\nnmap &lt;silent&gt; &lt;leader&gt;t :call TestNearest&lt;CR&gt;\nnmap &lt;silent&gt; &lt;leader&gt;T :call TestFile&lt;CR&gt;\nnmap &lt;silent&gt; &lt;leader&gt;a :call RunTestSuite()&lt;CR&gt;\nnmap &lt;silent&gt; &lt;leader&gt;l :call TestLast&lt;CR&gt;\nnmap &lt;silent&gt; &lt;leader&gt;g :call TestVisit&lt;CR&gt;</code></pre>\n      </div>\n<p>Iâ€™ve found it conventional to have a <code class=\"language-text\">bin/test_suite</code> or <code class=\"language-text\">bin/test</code> script in\nthe project that takes care of a lot of details like environment exports,\ncleanup, or making sure the test environmentâ€™s database is setup as well as\nrunning all the tests. Even if the test suite isnâ€™t complicated, itâ€™s still\nhelpful for new developers on the project.</p>\n<p>If that script is present and when I want to run all tests, I should execute\nthat file; otherwise use the default vim-test suite command. For non-suite\ntests, I use the default vim-test commands.</p>\n<p><code class=\"language-text\">&lt;space&gt;a</code> triggers the <strong>a</strong>ll tests. If a neoterm split isnâ€™t open,\nthen itâ€™ll automatically open on with the default settingsâ€” in my case, a\nvertical split at 80 columns wide. If a neoterm split is already open, then\nitâ€™ll send the test to that split. In situations where my vertical space is\nlacking, I prep by opening up a split, and then hit my test shortcut. <code class=\"language-text\">:HT</code> to\nopen the terminal up.</p>\n<p>If Iâ€™m testing a method or function, then <code class=\"language-text\">&lt;space&gt;t</code> to send the nearest\n<strong>t</strong>est to it. If Iâ€™m trying to make a test pass, Iâ€™ll modify the code and then\n<code class=\"language-text\">&lt;space&gt;l</code> to run the <strong>l</strong>ast test. If Iâ€™m refactoring a class or module, Iâ€™ll\nrun all the <strong>T</strong>ests for it. I havenâ€™t found myself using vim-testâ€™s TestVisit.\nIf you have some examples on where that command helps, Iâ€™d love to hear it!</p>\n<p>[ DEMO OF SENDING TESTS ]</p>\n<p>There might be a pesky app where I need to opt-into an environment variable but\nonly when Iâ€™m running a small amount of tests. vim-test letâ€™s me define my own\ntransformations to the commands. I can check for a certain file and string in it\nto determine what project Iâ€™m in. If Iâ€™m in that project, then modify the\ncommand where I can.</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">&quot; ~/.config/nvim/after/ftplugin/ruby.vim\n\nfunction! MyAppRspec(cmd) abort\n  &quot; If I&#39;m in the pesky app and\n  &quot; not running the entire test suite indicated by the --profile flag\n  &quot; Add the SKIP_FIXTURES env var.\n  if match(a:cmd, &#39;--profile&#39;) == -1 &amp;&amp; system(&quot;cat README.md | grep &#39;MyApp&#39;&quot;) == 0\n    return substitute(a:cmd, &#39;bundle exec&#39;, &#39;SKIP_FIXTURES=true bundle exec&#39;, &#39;&#39;)\n  else\n    return a:cmd\n  endif\nendfunction\n\nlet g:test#custom_transformations = {\n      \\ &#39;myapp_ruby&#39;: function(&#39;MyAppRspec&#39;)\n      \\ }\nlet g:test#transformation = &#39;myapp_ruby&#39;</code></pre>\n      </div>\n<p>[ DEMO OF TRANSFORMATION ]</p>\n<p>On the Elixir side, umbrella apps can be a little tricky. vim-test will send the\npath of the test to <code class=\"language-text\">mix test {file}</code>, but <code class=\"language-text\">mix</code> will run that command for each\nof the apps in the umbrella. Thatâ€™s probably not what we want to do since that\ntest exists for only one for apps. Again, we can solve it with a transformation.</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">&quot; ~/.config/nvim/after/ftplugin/elixir.vim\n\nfunction! ElixirUmbrellaTransform(cmd) abort\n  &quot; if in an umbrella project indicated by the existence of an ./apps folder\n  &quot; limit the mix command to the app to which the test belongs\n  if match(a:cmd, &#39;apps/&#39;) != -1\n    &quot; capture the app from the file path, and send it to the --app flag instead\n    return substitute(a:cmd, &#39;mix test apps/\\([^/]*\\)/&#39;, &#39;mix cmd --app \\1 mix test --color &#39;, &#39;&#39;)\n  else\n    return a:cmd\n  end\nendfunction\n\nlet g:test#custom_transformations = {\n       \\ &#39;elixir_umbrella&#39;: function(&#39;ElixirUmbrellaTransform&#39;)\n       \\ }\nlet g:test#transformation = &#39;elixir_umbrella&#39;</code></pre>\n      </div>\n<p>[ DEMO OF TRANSFORMATION ]</p>\n<p>Thatâ€™s it for tests!</p>\n<p>Hope you picked up something nifty. If you have any tips for me, send them my\nway <a href=\"https://twitter.com/bernheisel\">@bernheisel</a></p>","frontmatter":{"title":"VIM Testing and Workflow","date":"August 28, 2019","tags":["elixir","ruby","vim"],"originalUrl":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/vim-workflow/","previous":{"fields":{"slug":"/blog/httpoison-decompression/"},"frontmatter":{"title":"HTTPoison and Decompression","tags":["elixir"],"originalUrl":null,"excerpt":"I learned the hard way that the popular HTTP client for Elixir doesn't\nautomatically decompress or re-encode responses. I had to fix it myself.\n"}},"next":null}}