{"data":{"site":{"siteMetadata":{"title":"David Bernheisel","author":"David Bernheisel"}},"markdownRemark":{"id":"e50151a4-9f83-5375-ab30-8ad7515d2093","excerpt":"First off, Phoenix LiveView has been a dream to work with so far. I really\nrecommend looking at it for your next web application.One of the…","timeToRead":2,"html":"<p>First off, <a href=\"https://github.com/phoenixframework/phoenix_live_view\">Phoenix LiveView</a> has been a dream to work with so far. I really\nrecommend looking at it for your next web application.</p>\n<p>One of the things I love about LiveView is that it enables me to consolidate\nsome of common front-end logic into the backend, where the source of truth\nbelongs. A great example is a form, especially long-running or multi-step forms.</p>\n<p>Let me show you what I mean.</p>\n<video controls loop autoplay>\n  <source src=\"/long-form-demo-40ae7ab2ef6f6866b0efffa321f5f6c3.mp4\" type=\"video/mp4\">\n  <p>Your browser doesn't support HTML5 video. Here is\n     a <a href=\"/long-form-demo-40ae7ab2ef6f6866b0efffa321f5f6c3.mp4\">link to the video</a> instead.</p>\n</video>\n<p>There’s a couple of components you see in here:</p>\n<ul>\n<li>DatePicker (LiveView)</li>\n<li>Vue-mounted TipTap WYSIWYG editor (LiveView, and also mounts a Vue component)</li>\n<li>Recurrence component (hidden behind a checkbox, not demoed)</li>\n</ul>\n<p>I coded this form twice.</p>\n<h2>The Ugly Way</h2>\n<p>First, I coded it all with a single LiveView. I was still trying to figure out\nwhat I wanted on the form, but eventually this LiveView was an ugly 1000-line\nhorror that managed state in multiple places like the changeset and the socket.\nIt was pretty terrible. There has to be a better way. It’s a single <code class=\"language-text\">&lt;form&gt;</code>\nthat handled all the attributes, and each step was simply hidden until you hit\n“next”.</p>\n<p>It was something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"eex\">\n      <pre class=\"language-eex\"><code class=\"language-eex\">&lt;%= f = form_for(@changeset, phx_validate: :validate, phx_save: :save %&gt;\n\n&lt;div class=&quot;&lt;%= unless @step == &quot;who&quot;, do: &quot;hidden&quot; %&gt;&quot;&gt;\n  &lt;%# my Who-related form inputs %&gt;\n&lt;/div&gt;\n\n&lt;div class=&quot;&lt;%= unless @step == &quot;what&quot;, do: &quot;hidden&quot; %&gt;&quot;&gt;\n  &lt;%# my What-related form inputs %&gt;\n&lt;/div&gt;\n\n&lt;div class=&quot;&lt;%= unless @step == &quot;when&quot;, do: &quot;hidden&quot; %&gt;&quot;&gt;\n  &lt;%# my When-related form inputs %&gt;\n&lt;/div&gt;\n\n&lt;/form&gt;</code></pre>\n      </div>\n<p>This was fine when the form was smaller and simpler. However, I quickly found\nthat <strong>calculated fields</strong> can complicate things.</p>\n<p>For example, I need to persist two DateTimes with Timezone, but I don’t want to\npresent that to the user as <code class=\"language-text\">datetime_select</code>s and have them select a timezone\nfrom a dropdown.</p>\n<p>Instead I want a date picker, and then separately collect the times and merge it\nwith the user’s detected timezone (this would later be improved to allow them to\nselect a timezone). Something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"eex\">\n      <pre class=\"language-eex\"><code class=\"language-eex\">input(f, :date) ~D[2020-01-01] (Jan 1st)\ninput(f, :start_time) ~T[08:00:00] (8am)\ninput(f, :end_time) ~T[10:00:00] (10am)</code></pre>\n      </div>\n<p>These map internally to</p>\n<div class=\"gatsby-highlight\" data-language=\"elixir\">\n      <pre class=\"language-elixir\"><code class=\"language-elixir\">record<span class=\"token punctuation\">.</span>start_at_tz <span class=\"token comment\">#=> \"America/New_York\"</span>\nrecord<span class=\"token punctuation\">.</span>start_at_wall <span class=\"token comment\">#=> ~N[2020-01-01T08:00:00]</span>\nrecord<span class=\"token punctuation\">.</span>start_at_utc <span class=\"token comment\">#=> ~U[2020-01-01T13:00:00Z]</span>\n\nrecord<span class=\"token punctuation\">.</span>end_at_tz <span class=\"token comment\">#=> \"America/New_York\"</span>\nrecord<span class=\"token punctuation\">.</span>end_at_wall <span class=\"token comment\">#=> ~N[2020-01-01T10:00:00]</span>\nrecord<span class=\"token punctuation\">.</span>end_at_utc <span class=\"token comment\">#=> ~N[2020-01-01T15:00:00Z]</span>\n\nrecord<span class=\"token punctuation\">.</span>duration <span class=\"token comment\">#=> 7200 # seconds which is 2 hours</span></code></pre>\n      </div>\n<ol start=\"2\">\n<li>Second time around I decided to lean more into LiveComponents</li>\n</ol>","frontmatter":{"title":"Phoenix LiveView: Multi-step forms","date":"May 13, 2020","tags":["elixir","ecto","phoenix"],"originalUrl":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/liveview-multi-step-form/","previous":{"fields":{"slug":"/blog/vim-elixir-ls-plug/"},"frontmatter":{"title":"Managing ElixirLS updates in Neovim with asdf and vim-plug","tags":["elixir","vim"],"originalUrl":null,"excerpt":"How I manage ElixirLS, neovim, and coc.nvim with vim-plug."}},"next":null}}