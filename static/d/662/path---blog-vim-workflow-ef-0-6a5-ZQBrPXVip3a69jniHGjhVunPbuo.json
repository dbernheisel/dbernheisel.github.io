{"data":{"site":{"siteMetadata":{"title":"David Bernheisel","author":"David Bernheisel"}},"markdownRemark":{"id":"de95679a-bff6-51f7-9cd3-bc06a45f0594","excerpt":"I realized that I love my VIM workflow, so I want to share that with you.\nI am by-no-means a VIM expert or purist ‚Äî my neovim files are not‚Ä¶","timeToRead":5,"html":"<p>I realized that I love my VIM workflow, so I want to share that with you.\nI am by-no-means a VIM expert or purist ‚Äî my [neovim] files are not slim and\nare a melting pot of stolen code from others, sometimes modified or not,\nsometimes found in GitHub comments, sometimes found in others‚Äô dotfiles, or\nReddit comments.</p>\n<p>If you develop in Ruby or Elixir or write Markdown, you might find this helpful!</p>\n<p>Let‚Äôs start with some basics:</p>\n<h2>Environment</h2>\n<ul>\n<li>[neovim] - right now I‚Äôm using 0.4.0 so I can use floating windows.</li>\n<li>[ArchLinux]</li>\n<li>[i3]</li>\n<li>[kitty] Terminal Emulator</li>\n<li>built-in terminal in neovim</li>\n<li>[Plug] for managing neovim plugins.</li>\n<li>[nvim-coc] for languageserver integration.</li>\n<li>[dotfiles] - My dotfiles if you want the complete picture</li>\n</ul>\n<p>There are three ways that I can split my workspace: (1) via my window manager\ni3, (2) via my terminal emulator Kitty, (3) via neovim with splits/buffers.\nGenerally I adhere to this practice:</p>\n<ol>\n<li>Split with i3 if it‚Äôs an application, especially a GUI app. This gives me\nthe ability to move the window to another desktop if I want.</li>\n<li>Split with built-in neovim terminal for tests.</li>\n<li>Don‚Äôt split with kitty ever. It‚Äôd be too confusing having 3 sets of\nkeyboard shortcuts to keep track of for switching windows/panes/splits.</li>\n</ol>\n<p>[neovim]:\n[ArchLinux]:\n[i3]:\n[kitty]:\n[Plug]:\n[nvim-coc]:\n[dotfiles]:</p>\n<h2>Testing</h2>\n<p>I use [vim-test] and it‚Äôs pretty incredible. I picked this workflow up while\nworking at [thoughtbot] from some good friends, and it changed the way I code.\nThe whole TDD workflow is great despite that I still have trouble actually\nwriting tests first - I tend to spike, iterate, iterate, THEN write tests, then\nopen a PR. Yea‚Äî this probably means I‚Äôm not a 10x developer üòõ</p>\n<p>I also use neoterm to help open up terminal splits. When I‚Äôm at home, I have an\nultrawide that I use so splitting windows vertically is the way to go; but when\nI‚Äôm mobile with my laptop then I typically split horizontally. I want tests to\nbe visible either way, so I need this to be flexible.</p>\n<p>The vim-test neoterm strategy defaults to sending tests to the last-used neoterm\nbuffer; I can have more terminal buffers, but the first one I open is what\nvim-test will use going forward.</p>\n<p>[vim-test]:\n[neoterm]:\n[thoughtbot]:</p>\n<p>Here‚Äôs how I configure vim-test with neoterm.</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">&quot; `/.config/nvim/init.vim\n\n&quot; Test\nlet g:test#strategy = &quot;neoterm&quot;\nlet g:neoterm_shell = &#39;$SHELL -l&#39;\nlet g:neoterm_default_mod = &#39;vert&#39;\nlet g:neoterm_autoscroll = 1\nlet g:neoterm_size = 80\nlet g:neoterm_fixedsize = 1\nlet g:neoterm_keep_term_open = 0\nlet test#ruby#rspec#options = { &#39;suite&#39;: &#39;--profile 5&#39; }\n\n&quot; Create some commands that makes the splits easy\n\nfunction! OpenTermV(...)\n  let g:neoterm_size = 80\n  let l:cmd = a:1 == &#39;&#39; ? &#39;pwd&#39; : a:1\n  execute &#39;vert T &#39;.l:cmd\nendfunction\n\nfunction! OpenTermH(...)\n  let g:neoterm_size = 10\n  let l:cmd = a:1 == &#39;&#39; ? &#39;pwd&#39; : a:1\n  execute &#39;belowright T &#39;.l:cmd\nendfunction\n\ncommand! -nargs=? VT call OpenTermV(&lt;q-args&gt;)\ncommand! -nargs=? HT call OpenTermH(&lt;q-args&gt;)\n\n&quot; Use the project&#39;s test suite script if it exists\n\nfunction! RunTestSuite()\n  Tclear\n  if filereadable(&#39;bin/test_suite&#39;)\n    T echo &#39;bin/test_suite&#39;\n    T bin/test_suite\n  elseif filereadable(&quot;bin/test&quot;)\n    T echo &#39;bin/test&#39;\n    T bin/test\n  else\n    TestSuite\n  endif\nendfunction\n\nnmap &lt;silent&gt; &lt;leader&gt;t :call TestNearest&lt;CR&gt;\nnmap &lt;silent&gt; &lt;leader&gt;T :call TestFile&lt;CR&gt;\nnmap &lt;silent&gt; &lt;leader&gt;a :call RunTestSuite()&lt;CR&gt;\nnmap &lt;silent&gt; &lt;leader&gt;l :call TestLast&lt;CR&gt;</code></pre>\n      </div>\n<p>I‚Äôve found it conventional to have a <code class=\"language-text\">bin/test_suite</code> or <code class=\"language-text\">bin/test</code> script in\nthe project that takes care of a lot of details like environment exports,\ncleanup, or making sure the test environment‚Äôs database is setup as well as\nrunning all the tests. Even if the test suite isn‚Äôt complicated, it‚Äôs still\nhelpful for new developers on the project.</p>\n<p>If that script is present and when I want to run all tests, I should execute\nthat file; otherwise use the default vim-test suite command. For non-suite\ntests, I use the default vim-test commands.</p>\n<p><code class=\"language-text\">&lt;space&gt;a</code> triggers the whole suite. ‚ÄúA for all tests‚Äù. If a neoterm split isn‚Äôt\nopen, then it‚Äôll automatically open on with the default settings‚Äî in my case, a\nvertical split at 80 columns wide. If a neoterm split is already open, then\nit‚Äôll send the test to that split. In situations where my vertical space is\nlacking, I prep by opening up a split, and then hit my test shortcut. <code class=\"language-text\">:HT</code> to\nopen the terminal up.</p>\n<p>In any case, I trigger the tests with <code class=\"language-text\">&lt;space&gt;t</code> to send the nearest test, ‚Äút\nfor this test‚Äù; or <code class=\"language-text\">&lt;space&gt;T</code> ‚ÄúT for tests‚Äù; or <code class=\"language-text\">&lt;space&gt;l</code> ‚ÄúLast test‚Äù.</p>\n<p>[ DEMO OF SENDING TESTS ]</p>\n<p>This is a great start! But eventually there might be a pesky app where I need to\nopt-into an environment variable, but only when I‚Äôm running a small number of\ntests. vim-test let‚Äôs me define my own transformations to the commands. I can\ncheck for a certain file and string in it to determine what project I‚Äôm in. If\nI‚Äôm in that project, then change the command where I can.</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">&quot; ~/.config/nvim/after/ftplugin/ruby.vim\n\nfunction! MyAppRspec(cmd) abort\n  &quot; If I&#39;m in the pesky app and\n  &quot; not running the entire test suite indicated by the --profile flag\n  &quot; Add the SKIP_FIXTURES env var.\n  if match(a:cmd, &#39;--profile&#39;) == -1 &amp;&amp; system(&quot;cat README.md | grep &#39;MyApp&#39;&quot;) == 0\n    return substitute(a:cmd, &#39;bundle exec&#39;, &#39;SKIP_FIXTURES=true bundle exec&#39;, &#39;&#39;)\n  else\n    return a:cmd\n  endif\nendfunction\n\nlet g:test#custom_transformations = {\n      \\ &#39;myapp_ruby&#39;: function(&#39;MyAppRspec&#39;)\n      \\ }\nlet g:test#transformation = &#39;myapp_ruby&#39;</code></pre>\n      </div>\n<p>[ DEMO OF TRANSFORMATION ]</p>\n<p>On the Elixir side, umbrella apps can be a little tricky. vim-test will send the\npath of the test to <code class=\"language-text\">mix test {file}</code>, but <code class=\"language-text\">mix</code> will run that command for each\nof the apps in the umbrella. That‚Äôs probably not what we want to do since that\ntest exists for only one for apps. Again, we can solve it with a transformation.</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">&quot; ~/.config/nvim/after/ftplugin/elixir.vim\n\nfunction! ElixirUmbrellaTransform(cmd) abort\n  &quot; if in an umbrella project indicated by the existence of an ./apps folder\n  &quot; limit the mix command to the app to which the test belongs\n  if match(a:cmd, &#39;apps/&#39;) != -1\n    &quot; capture the app from the file path, and send it to the --app flag instead\n    return substitute(a:cmd, &#39;mix test apps/\\([^/]*\\)/&#39;, &#39;mix cmd --app \\1 mix test --color &#39;, &#39;&#39;)\n  else\n    return a:cmd\n  end\nendfunction\n\nlet g:test#custom_transformations = {\n       \\ &#39;elixir_umbrella&#39;: function(&#39;ElixirUmbrellaTransform&#39;)\n       \\ }\nlet g:test#transformation = &#39;elixir_umbrella&#39;</code></pre>\n      </div>\n<p>[ DEMO OF TRANSFORMATION ]</p>\n<p>That‚Äôs it for tests! Now let‚Äôs check out Language Server integration</p>\n<h2>Language Server Integration with Neovim and nvim-coc</h2>","frontmatter":{"title":"VIM Workflow and App Testing Setup","date":"July 29, 2019","tags":["elixir","ruby","vim"],"originalUrl":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/vim-workflow/","previous":{"fields":{"slug":"/blog/httpoison-decompression/"},"frontmatter":{"title":"HTTPoison and Decompression","tags":["elixir"],"originalUrl":null,"excerpt":"I learned the hard way that the popular HTTP client for Elixir doesn't\nautomatically decompress or re-encode responses. I had to fix it myself.\n"}},"next":null}}