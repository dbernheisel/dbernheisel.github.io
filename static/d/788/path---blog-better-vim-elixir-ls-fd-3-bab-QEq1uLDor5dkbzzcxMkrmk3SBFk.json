{"data":{"site":{"siteMetadata":{"title":"David Bernheisel","author":"David Bernheisel"}},"markdownRemark":{"id":"b0ff425e-4bba-5df7-a3e1-4c86445e05f6","excerpt":"tldr:Problem ArisesRecently I upgraded a project to Elixir 1.10, and this version of Elixir\nintroduces . I’m working in the project, and…","timeToRead":7,"html":"<p>tldr:</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">let g:ElixirLS = {&quot;path&quot;: &quot;&quot;, &quot;installed&quot;: 0, &quot;installing&quot;: 0}\n\nfunction g:ElixirLS.get_info() abort\n  if !strlen(g:ElixirLS.path)\n    let g:ElixirLS.install_into = system(&quot;asdf which elixir&quot;, &quot;silent&quot;)[:-12]\n    if !v:shell_error\n      let g:ElixirLS.path = g:ElixirLS.install_into . &#39;elixir_ls&#39;\n      let g:ElixirLS.bin = g:ElixirLS.path . &quot;/release/language_server.sh&quot;\n      let g:ElixirLS.installed = executable(g:ElixirLS.bin)\n    endif\n  endif\n  return g:ElixirLS\nendfunction\n\nfunction g:ElixirLS.on_stderr(_job_id, data, event) abort\n   echom join(a:data, &quot;\\n&quot;)\nendfunction\n\nfunction g:ElixirLS.on_exit(_job_id, data, event) abort\n  if a:data == 0\n    let g:ElixirLS.installed = 1\n    echom &quot;&gt;&gt;&gt; Finished compiling ElixirLS&quot;\n    execute &quot;CocRestart&quot;\n  else\n    let g:ElixirLS.installing = 0\n    echom &quot;&gt;&gt;&gt; There was a problem installing ElixirLS. Check :messages&quot;\n  endif\nendfunction\n\nfunction g:ElixirLS.install() abort\n  let me = copy(g:ElixirLS.get_info())\n  if me.installed || me.installing\n    return\n  else\n    let g:ElixirLS.installing = 1\n    echom &quot;&gt;&gt;&gt; Compiling ElixirLS&quot;\n    let toolversion = fnamemodify(findfile(&quot;.tool-versions&quot;, &quot;.;&quot;), &quot;:p&quot;)\n    call jobstart(&quot;git clone https://github.com/elixir-lsp/elixir-ls.git &#39;&quot; . me.path . &quot;&#39; &amp;&amp; &quot;.\n          \\ &quot;cd &#39;&quot; . me.path . &quot;&#39; &amp;&amp; &quot;.\n          \\ &quot;rm .tool-versions &amp;&amp; &quot;.\n          \\ &quot;cp &quot; . toolversion . &quot; .tool-versions &amp;&amp; &quot;.\n          \\ &quot;mix local.hex --force --if-missing &amp;&amp; &quot;.\n          \\ &quot;mix local.rebar --force &amp;&amp; &quot;.\n          \\ &quot;mix deps.get &amp;&amp; &quot;.\n          \\ &quot;mix compile &amp;&amp; &quot;.\n          \\ &quot;mix elixir_ls.release&quot;, me)\n  endif\n  call coc#config(&#39;elixir.pathToElixirLS&#39;, me.bin)\nendfunction\n\naugroup elixirLS\n  autocmd FileType elixir call g:ElixirLS.install()\naugroup END</code></pre>\n      </div>\n<h2>Problem Arises</h2>\n<p>Recently I upgraded a project to Elixir 1.10, and this version of Elixir\nintroduces <a href=\"https://hexdocs.pm/elixir/1.10.0/Application.html#compile_env/3\"><code class=\"language-text\">Application.compile_env</code></a>. I’m working in the project, and\neverything’s fine until I want to pull the documentation for the new function…</p>\n<p>… it doesn’t show; in fact the language server is telling me this function\ndoesn’t exist. But of course it does! What’s wrong?</p>\n<p>My language server was compiled with Elixir 1.8.2-otp-21 and was installed into\none folder in my drive that all my projects look at, so it acts like a global\nlanguage server.</p>\n<p><img src=\"/ugh-40b6774b66241e08a7ad6e1416713899.gif\" alt=\"ugh...\"></p>\n<h2>Other Solutions?</h2>\n<p>There are several articles out there that assist vimmers in getting ElixirLS\nsetup for them. Here are some:</p>\n<ul>\n<li><a href=\"https://medium.com/@hauleth/dumb-elixir-visual-and-improved-editor-53c23a0800e4\">https://medium.com/@hauleth/dumb-elixir-visual-and-improved-editor-53c23a0800e4</a></li>\n<li><a href=\"https://www.mitchellhanberg.com/post/2018/10/18/how-to-use-elixir-ls-with-vim/\">https://www.mitchellhanberg.com/post/2018/10/18/how-to-use-elixir-ls-with-vim/</a></li>\n<li><a href=\"https://dev.to/sophiabrandt/neovim-and-languageclient-for-elixir-1p8b\">https://dev.to/sophiabrandt/neovim-and-languageclient-for-elixir-1p8b</a></li>\n<li><a href=\"https://www.rockyourcode.com/developing-with-elixir-in-vim/\">https://www.rockyourcode.com/developing-with-elixir-in-vim/</a></li>\n</ul>\n<p>But they all lead developers to install The One Global ElixirLS, and I supposed\nif you upgrade your project, you’d want to recompile your One Global ElixirLS\ntoo.</p>\n<h2>My Solution</h2>\n<p><img src=\"/time-for-solution-9eaf33a65a6fab255262cbb4d3262033.gif\" alt=\"time to VimScript it\"></p>\n<p>This solution is unabashedly about my setup. I use <a href=\"https://github.com/asdf-vm/asdf\">asdf</a>,\n<a href=\"https://github.com/elixir-lsp/elixir-ls\">elixir-lsp/elixir-ls</a>, <a href=\"https://github.com/neoclide/coc.nvim\">coc.nvim</a>, <a href=\"https://github.com/amiralies/coc-elixir\">coc-elixir</a> to tell coc about ElixirLS, and\n<a href=\"https://neovim.io/\">neovim</a>. If you don’t use these these tools, my vimscript will not work for you\nwithout modification.</p>\n<p>Let’s walk through it. Read through the comments.</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">&quot; Initialize a global dictionary. It&#39;s going to assume we are not installed\nlet g:ElixirLS = {&quot;path&quot;: &quot;&quot;, &quot;installed&quot;: 0, &quot;installing&quot;: 0}\n\n&quot; Define a function on the dictionary &#39;get_info&#39; key\nfunction g:ElixirLS.get_info() abort\n  &quot; If the path is empty, like when initialized, let&#39;s gather all this intel.\n  &quot; If we already know the path, that means we&#39;ve already run through this code\n  &quot; path and don&#39;t need to query asdf again, which keeps things fast\n  if !strlen(g:ElixirLS.path)\n    &quot; shell out and get the path to the current location of elixir\n    &quot; This implies that it will only work for your project when you\n    &quot; open neovim from within the project folder. We&#39;re cutting the last 12\n    &quot; characters off because we don&#39;t want the newline, nor the /bin/elixir\n\n    &quot; `asdf which elixir` returns &#39;/home/dbernheisel/.asdf/installs/elixir/1.10.0-otp-22/bin/elixir&#39;\n    &quot; and I want &#39;/home/dbernheisel/.asdf/installs/elixir/1.10.0-otp-22&#39;\n    let g:ElixirLS.install_into = system(&quot;asdf which elixir&quot;, &quot;silent&quot;)[:-12]\n\n    &quot; if `asdf which elixir` doesn&#39;t return in an error, let&#39;s keep going\n    if !v:shell_error\n\n      &quot; let&#39;s install elixir_ls into the .../1.10.0-otp-22/elixir_ls folder\n      let g:ElixirLS.path = g:ElixirLS.install_into . &#39;elixir_ls&#39;\n\n      &quot; We&#39;ll need to tell coc.nvim the new path to the language server\n      &quot; executable\n      let g:ElixirLS.bin = g:ElixirLS.path . &quot;/release/language_server.sh&quot;\n\n      &quot; Finally, if it&#39;s already present and executable, let&#39;s send a batsignal\n      &quot; up so say we&#39;re installed. This also has the benefit\n      let g:ElixirLS.installed = executable(g:ElixirLS.bin)\n    endif\n  endif\n\n  return g:ElixirLS\nendfunction</code></pre>\n      </div>\n<p>The basic flow so far is:</p>\n<ol>\n<li>Use <code class=\"language-text\">asdf which elixir</code> to grab the current Elixir’s installed path.</li>\n<li>We’re going to install ElixirLS into the same path into a <code class=\"language-text\">./elixir_ls</code>\nfolder.</li>\n<li>Check if everything’s already installed.</li>\n<li>We should only have to get_info() once during a vim session, which keeps\nthings fast and only hits <code class=\"language-text\">asdf</code> once.</li>\n</ol>\n<p>Moving on!</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">&quot; Define a function on the dictionary &#39;install&#39; key\nfunction g:ElixirLS.install() abort\n  &quot; Let&#39;s get a copy of the global information we already know.\n  let me = copy(g:ElixirLS.get_info())\n\n  &quot; If ElixirLS is already installed... well... we&#39;re done so leave. We&#39;re also\n  &quot; going to check if we&#39;re in process of installing it since there could be\n  &quot; multiple calls to g:ElixirLS.install() before it&#39;s finished. In Vimscript\n  &quot; 0 is falsey, so later we&#39;ll want to set it to 1 which is truthy.\n  if me.installed || me.installing\n    return\n  else\n    &quot; Mark that we&#39;re starting the installation process so we don&#39;t clobber\n    &quot; ourselves and get confusing errors.\n    let g:ElixirLS.installing = 1\n    &quot; Let&#39;s send a message so we can debug later where we are in the process\n    echom &quot;&gt;&gt;&gt; Compiling ElixirLS&quot;\n\n    &quot; Ok, this is hack, but elixir-lsp/elixir-ls ships with their own asdf\n    &quot; .tool-versions file, which I don&#39;t want since I want to compile it with\n    &quot; the same version of my project. Let&#39;s find it. This vimscript function\n    &quot; will travel upwards until it finds the file and returns `.tool-versions`\n    &quot; and then we expand the file to an absolute path with `fnamemodify`\n    let toolversion = fnamemodify(findfile(&quot;.tool-versions&quot;, &quot;.;&quot;), &quot;:p&quot;)\n\n    &quot; Here&#39;s the Neovim-specific part. Vim8+ has async jobs so if you&#39;re not\n    &quot; using neovim, you can probably port this to whatever vim8 uses. We&#39;re\n    &quot; essentially going to clone ElixirLS and compile it with our project&#39;s\n    &quot; tool-versions file. If we didn&#39;t use jobstart() and instead used system()\n    &quot; or execute() it would be synchronous, and your vim would be frozen for a\n    &quot; good 20 seconds or so.\n    call jobstart(&quot;git clone https://github.com/elixir-lsp/elixir-ls.git &#39;&quot; . me.path . &quot;&#39; &amp;&amp; &quot;.\n          \\ &quot;cd &#39;&quot; . me.path . &quot;&#39; &amp;&amp; &quot;.\n          \\ &quot;rm .tool-versions &amp;&amp; &quot;.\n          \\ &quot;cp &quot; . toolversion . &quot; .tool-versions &amp;&amp; &quot;.\n          \\ &quot;mix local.hex --force --if-missing &amp;&amp; &quot;.\n          \\ &quot;mix local.rebar --force &amp;&amp; &quot;.\n          \\ &quot;mix deps.get &amp;&amp; &quot;.\n          \\ &quot;mix compile &amp;&amp; &quot;.\n          \\ &quot;mix elixir_ls.release&quot;, me)\n      &quot; Neovim supplies jobstart() which accepts several callbacks:\n      &quot;   - on_stdout\n      &quot;   - on_stderr\n      &quot;   - on_exit\n\n      &quot; See :h job-control for more information.\n  endif\n\n  &quot; Let&#39;s update coc-elixir&#39;s configuration to point to our ElixirLS executable\n  &quot; This doesn&#39;t take into effect yet though.\n  call coc#config(&#39;elixir.pathToElixirLS&#39;, me.bin)\nendfunction\n\n&quot; Whenever we enter into an Elixir file, we should try to install ElixirLS. If\n&quot; you know of a better way to manage this lifecycle, let me know. I tried to\n&quot; make it performant with early returns and only running once, but I feel like\n&quot; there might be a better hook.\naugroup cocEx\n  autocmd FileType elixir,eelixir call g:ElixirLS.install()\naugroup END</code></pre>\n      </div>\n<p>The basic flow so far is:</p>\n<ol>\n<li>Use <code class=\"language-text\">asdf which elixir</code> to grab the current Elixir’s installed path.</li>\n<li>We’re going to install ElixirLS into the same path into a <code class=\"language-text\">./elixir_ls</code>\nfolder.</li>\n<li>Check if everything’s already installed.</li>\n<li>We should only have to <code class=\"language-text\">get_info()</code> once during a vim session, which keeps\nthings fast and only hits <code class=\"language-text\">asdf</code> once.</li>\n<li>When we enter an Elixir file, run <code class=\"language-text\">install()</code>. If it’s already installed,\nthen return early to keep things fast.</li>\n</ol>\n<p>Moving on! Only the callbacks now…</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">&quot; Define a function on the dictionary &#39;on_stderr&#39; key\nfunction g:ElixirLS.on_stderr(_job_id, data, event) abort\n  &quot; All we&#39;re going to do is add the errors into vim&#39;s messages. Neovim sends\n  &quot; these as lists, so we&#39;ll join them since we can only echo string messages\n  echom join(a:data, &quot;\\n&quot;)\nendfunction\n\n&quot; Define a function on the dictionary &#39;on_exit&#39; key\nfunction g:ElixirLS.on_exit(_job_id, data, event) abort\n  &quot; if the exit code 0, meaning successful, then we&#39;ve done something right!\n  if a:data == 0\n    &quot; Mark ourselves as installed so we don&#39;t do this process again\n    let g:ElixirLS.installed = 1\n    echom &quot;&gt;&gt;&gt; Finished compiling ElixirLS&quot;\n\n    &quot; Restart coc.nvim so it can use the newly-compiled ElixirLS executable\n    execute &quot;CocRestart&quot;\n  else\n    &quot; Unmark that we&#39;re installing, so if we wanted to try again, we could.\n    let g:ElixirLS.installing = 0\n    echom &quot;&gt;&gt;&gt; There was a problem installing ElixirLS. Check :messages&quot;\n  endif\nendfunction</code></pre>\n      </div>\n<p>And there you have it — a self-installing ElixirLS with neovim and coc.nvim.</p>","frontmatter":{"title":"Better Elixir LS with Neovim, coc.nvim, and asdf","date":"February 01, 2020","tags":["elixir","neovim","asdf"],"originalUrl":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/better-vim-elixir-ls/","previous":{"fields":{"slug":"/blog/ecto_changeset_tips/"},"frontmatter":{"title":"Ecto Tips: UUID Boilerplate, Docs, and Composing Changesets","tags":["elixir","ecto"],"originalUrl":null,"excerpt":"There are some helpful techniques you can employ to help you and your\ncoworkers when writing long changeset functions. It's hard to remember what's\nrequired, optional, and defaulted. DB-generated UUIDs. And composing\nchangesets.\n"}},"next":null}}