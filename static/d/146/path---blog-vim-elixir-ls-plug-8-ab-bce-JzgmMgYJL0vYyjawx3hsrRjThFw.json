{"data":{"site":{"siteMetadata":{"title":"David Bernheisel","author":"David Bernheisel"}},"markdownRemark":{"id":"49499868-28ad-5e00-b262-677c05e9204f","excerpt":"Kassio’s Post was inspirational, and I adapted from his setup. My setup is a\nlittle different from his:I use asdf to manage my installed…","timeToRead":9,"html":"<p><a href=\"https://kassio.github.io/2019/03/21/elixir-ls-on-coc.nvim.html\">Kassio’s Post</a> was inspirational, and I adapted from his setup. My setup is a\nlittle different from his:</p>\n<ul>\n<li>I use <a href=\"https://asdf-vm.com\">asdf</a> to manage my installed Elixir and Erlang versions. The ElixirLS\nproject has a tested Elixir version it was developed with; and I’d like to\nuse that same version. I also don’t want to have to worry about not having\nthe same installed versions as them.</li>\n<li>I use <a href=\"https://github.com/junegunn/vim-plug\">vim-plug</a>. It has a neat feature where you can clone any repository\nwhether or not it’s built for vim or not. In this case, I’m going to use it\nto grab a copy of ElixirLS, and have it run a post-update hook. ElixirLS\ndoesn’t have any vim code that gets loaded, so it’s benign.</li>\n<li>I wanted to let the compilation happen asynchronously. I don’t want\ncompilation to lock up the UI.</li>\n</ul>\n<h2>The Proof</h2>\n<p>Here’s <a href=\"https://github.com/elixir-lsp/elixir-ls\">ElixirLS</a> in action inside vim with <a href=\"https://github.com/neoclide/coc.nvim\">nvim.coc</a>:</p>\n<p><img src=\"/elixir-ls-in-action-f6f1d6938623362156f48bff95e7ee5e.gif\" alt=\"Elixir LS in action\"></p>\n<p>Here’s me manually calling to update ElixirLS. I have a terminal on the right\nthat is watching the filesystem so we can see it’s actually doing something:</p>\n<p><img src=\"/ManuallyCalling-2dc5c9710c16b2cc959adb3103a58caa.gif\" alt=\"Elixir Manual Update\"></p>\n<p>Here’s me using vim-plug to update ElixirLS. I have a terminal on the right\nthat is watching the filesystem so we can see it’s actually doing something:</p>\n<p><img src=\"/PlugUpdate-4ffe506c18effd46392cef0a61e55a4b.gif\" alt=\"Elixir Manual Update\"></p>\n<h2>The Vimscript</h2>\n<p>Here’s the vim setup:</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">call plug#begin(&#39;~/.config/nvim/plugged&#39;)\n  Plug &#39;elixir-lsp/elixir-ls&#39;, { &#39;do&#39;: { -&gt; g:ElixirLS.compile() } }\n  Plug &#39;neoclide/coc.nvim&#39;, {&#39;branch&#39;: &#39;release&#39;}\ncall plug#end()\n\nlet g:coc_global_extensions = [&#39;coc-elixir&#39;, &#39;coc-diagnostic&#39;]\n\nlet g:ElixirLS = {}\nlet ElixirLS.path = stdpath(&#39;config&#39;).&#39;/plugged/elixir-ls&#39;\nlet ElixirLS.lsp = ElixirLS.path.&#39;/release/language_server.sh&#39;\nlet ElixirLS.cmd = join([\n        \\ &#39;asdf install &amp;&amp;&#39;,\n        \\ &#39;mix do&#39;,\n        \\ &#39;local.hex --force --if-missing,&#39;,\n        \\ &#39;local.rebar --force,&#39;,\n        \\ &#39;deps.get,&#39;,\n        \\ &#39;compile,&#39;,\n        \\ &#39;elixir_ls.release&#39;\n        \\ ], &#39; &#39;)\n\nfunction ElixirLS.on_stdout(_job_id, data, _event)\n  let self.output[-1] .= a:data[0]\n  call extend(self.output, a:data[1:])\nendfunction\n\nlet ElixirLS.on_stderr = function(ElixirLS.on_stdout)\n\nfunction ElixirLS.on_exit(_job_id, exitcode, _event)\n  if a:exitcode[0] == 0\n    echom &#39;&gt;&gt;&gt; ElixirLS compiled&#39;\n  else\n    echoerr join(self.output, &#39; &#39;)\n    echoerr &#39;&gt;&gt;&gt; ElixirLS compilation failed&#39;\n  endif\nendfunction\n\nfunction ElixirLS.compile()\n  let me = copy(g:ElixirLS)\n  let me.output = [&#39;&#39;]\n  echom &#39;&gt;&gt;&gt; compiling ElixirLS&#39;\n  let me.id = jobstart(&#39;cd &#39; . me.path . &#39; &amp;&amp; git pull &amp;&amp; &#39; . me.cmd, me)\nendfunction\n\n&quot;&quot; If you want to wait on the compilation only when running :PlugUpdate\n&quot;&quot; then have the post-update hook use this function instead:\n&quot; function ElixirLS.compile_sync()\n&quot;   echom &#39;&gt;&gt;&gt; compiling ElixirLS&#39;\n&quot;   silent call system(g:ElixirLS.cmd)\n&quot;   echom &#39;&gt;&gt;&gt; ElixirLS compiled&#39;\n&quot; endfunction\n\n\n&quot;&quot; Then, update the Elixir language server\ncall coc#config(&#39;elixir&#39;, {\n  \\ &#39;command&#39;: g:ElixirLS.lsp,\n  \\ &#39;filetypes&#39;: [&#39;elixir&#39;, &#39;eelixir&#39;]\n  \\})\ncall coc#config(&#39;elixir.pathToElixirLS&#39;, g:ElixirLS.lsp)</code></pre>\n      </div>\n<p>And this is in my <code class=\"language-text\">:CocConfig</code> (<code class=\"language-text\">~/.config/nvim/coc-settings.json</code>):</p>\n<div class=\"gatsby-highlight\" data-language=\"json\">\n      <pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"codeLens.enable\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"diagnostic-languageserver.filetypes\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"elixir\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"mix_credo\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"mix_credo_compile\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"eelixir\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"mix_credo\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"mix_credo_compile\"</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<h2>Include coc.nvim, ElixirLS in plug</h2>\n<p>Starting from the top:</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">call plug#begin(&#39;~/.config/nvim/plugged&#39;)\n  Plug &#39;elixir-lsp/elixir-ls&#39;, { &#39;do&#39;: { -&gt; g:ElixirLS.compile() } }\n  Plug &#39;neoclide/coc.nvim&#39;, {&#39;branch&#39;: &#39;release&#39;}\ncall plug#end()\n\nlet g:coc_global_extensions = [&#39;coc-elixir&#39;, &#39;coc-diagnostic&#39;]</code></pre>\n      </div>\n<p>I’m using vim-plug to grab some plugins. All we care about for now is coc.nvim\nand elixir-ls. I’m providing options for elixir-ls to perform an after-update\naction. In this case, a lambda which immediately evaluates <code class=\"language-text\">{ &#39;do&#39;: { -&gt; g:ElixirLS.compile() } }</code></p>\n<p>To learn more about the vim lambda, check out <code class=\"language-text\">:h expr-lambda</code>. We’re going to\nlook at the <code class=\"language-text\">ElixirLS.compile()</code> function later.</p>\n<p>The coc.nvim setup is straight from their readme. I’m also adding some\nextensions that nvim.coc will install on its own after startup. In this case I\nwant <a href=\"https://github.com/amiralies/coc-elixir\">coc-elixir</a> and <a href=\"https://github.com/iamcco/coc-diagnostic\">coc-diagnostic</a>.</p>\n<p>coc-elixir provides coc.nvim the settings to know how to work with Elixir\nprojects and the language server. It also will build ElixirLS on its own, but\nwe’re going to circumvent that in a moment.</p>\n<p>coc-diagnostic is a generic bridge for many non-Language-Server tools like\nshellcheck and credo. In this case, I’m adding it for credo. I don’t need\ncoc-diagnostic to provide a formatter, since the main Elixir language server\nwill provide that already.</p>\n<h2>Define your vim ElixirLS dictionary</h2>\n<p>Next we’re going to create a dictionary with a couple of functions. This dict is\ngoing to manage several things for us:</p>\n<ul>\n<li>The path to the language server executable and directory.</li>\n<li>The commands to run when needing to compile</li>\n<li>Job hook functions so Neovim can run this task asynchronously</li>\n</ul>\n<p>Check out <code class=\"language-text\">:h dictionary-function</code> in vim for more info on how to be a bit more\nobject-oriented in your vim scripts. If you go down this rabbit hole, I really\nencourage you to look into <code class=\"language-text\">:h lua</code> as well which is better-suited for serious\nvim programming.</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">let g:ElixirLS = {}\nlet ElixirLS.path = stdpath(&#39;config&#39;).&#39;/plugged/elixir-ls&#39;\nlet ElixirLS.lsp = ElixirLS.path.&#39;/release/language_server.sh&#39;\nlet ElixirLS.cmd = join([\n        \\ &#39;asdf install &amp;&amp;&#39;,\n        \\ &#39;mix do&#39;,\n        \\   &#39;local.hex --force --if-missing,&#39;,\n        \\   &#39;local.rebar --force,&#39;,\n        \\   &#39;deps.get,&#39;,\n        \\   &#39;compile,&#39;,\n        \\   &#39;elixir_ls.release&#39;\n        \\ ], &#39; &#39;)</code></pre>\n      </div>\n<p>So far it’s pretty standard stuff. We initialize an empty global dictionary\nfirst, then start stuffing some values in there. We’re using the function\n<code class=\"language-text\">stdpath</code> so we avoid hard-coding any paths.</p>\n<p>The <code class=\"language-text\">join([...], &#39; &#39;)</code> is only a way to organize the commands in a visual way.\nIt’s not necessary; you can totally just concat some strings together. The end\nresult of this join is:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\">\n      <pre class=\"language-sh\"><code class=\"language-sh\">asdf install &amp;&amp; mix do local.hex --force --if-missing, local.rebar --force, deps.get, compile, elixir_ls.release</code></pre>\n      </div>\n<p>Since I’m using <a href=\"https://asdf-vm.com\">asdf</a> I want to make sure I’m using the ElixirLS developers’\ntools so I know for sure I won’t run into trouble while developing. I want my\nElixirLS to be stable since it’s such an important tool for me.</p>\n<p>We’re going to leverage <a href=\"https://hexdocs.pm/mix/Mix.Tasks.Do.html\">mix do</a> so we’re not starting Erlang multiple for each\ncommand. This should speed some things up.</p>\n<h2>Run it in the background</h2>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">function ElixirLS.on_stdout(_job_id, data, _event)\n  let self.output[-1] .= a:data[0]\n  call extend(self.output, a:data[1:])\nendfunction\n\nlet ElixirLS.on_stderr = function(ElixirLS.on_stdout)\n\nfunction ElixirLS.on_exit(_job_id, exitcode, _event)\n  if a:exitcode[0] == 0\n    echom &#39;&gt;&gt;&gt; ElixirLS compiled&#39;\n  else\n    echoerr join(self.output, &#39; &#39;)\n    echoerr &#39;&gt;&gt;&gt; ElixirLS compilation failed&#39;\n  endif\nendfunction\n\nfunction ElixirLS.compile()\n  let me = copy(g:ElixirLS)\n  let me.output = [&#39;&#39;]\n  echom &#39;&gt;&gt;&gt; compiling ElixirLS&#39;\n  let me.id = jobstart(&#39;cd &#39; . me.path . &#39; &amp;&amp; git pull &amp;&amp; &#39; . me.cmd, me)\nendfunction</code></pre>\n      </div>\n<p>These functions are adding keys to the ElixirLS dictionary. If I echo out the\ndictionary, you’ll see a normal dictionary with some funcrefs.</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">:echo ElixirLS\n{\n  &#39;cmd&#39;: &#39;asdf install &amp;&amp; mix do local.hex --force --if-missing, local.rebar --force, deps.get, compile, elixir_ls.release&#39;,\n  &#39;path&#39;: &#39;/home/me/.config/nvim/plugged/elixir-ls&#39;,\n  &#39;on_exit&#39;: function(&#39;2&#39;),\n  &#39;on_stdout&#39;: function(&#39;1&#39;),\n  &#39;lsp&#39;: &#39;/home/me/.config/nvim/plugged/elixir-ls/release/language_server.sh&#39;,\n  &#39;on_stderr&#39;: function(&#39;1&#39;, {...@0}),\n  &#39;compile&#39;: function(&#39;3&#39;)\n}</code></pre>\n      </div>\n<p>One of the great things about Neovim (and Vim8+) is that it really pushed\nasynchronous work forward. Neovim introduced some functions to manage background\njobs. The one we end up using is <code class=\"language-text\">jobstart({cmd}[, {opts}])</code> (check out <code class=\"language-text\">:h jobstart</code>).</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">function ElixirLS.compile()\n  let me = copy(g:ElixirLS)\n  let me.output = [&#39;&#39;]\n  echom &#39;&gt;&gt;&gt; compiling ElixirLS&#39;\n  let me.id = jobstart(&#39;cd &#39; . me.path . &#39; &amp;&amp; git pull &amp;&amp; &#39; . me.cmd, me)\nendfunction</code></pre>\n      </div>\n<p>First we’re going to make a copy of the dictionary since this can be\nasynchronous; we’ll call it <code class=\"language-text\">me</code>. Then we’ll initialize a new key <code class=\"language-text\">output</code> so we\ncan store all the background job’s output into it. Lastly, we’ll start the job.\nThe first argument (if a string) will shell out and execute the command you fed\nit.</p>\n<p>Here’s the complete command that ends up being sent:</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\">\n      <pre class=\"language-sh\"><code class=\"language-sh\">cd {the-path} &amp;&amp; \\\n  git pull &amp;&amp; \\\n  asdf install &amp;&amp; \\\n  mix do local.hex --force --if-missing, local.rebar --force, deps.get, compile, elixir_ls.release</code></pre>\n      </div>\n<p><strong>If you’re only using this via vim-plug</strong>, then vim-plug will take care of the\n<code class=\"language-text\">cd {the-path} &amp;&amp; git pull</code> on its own, so we don’t need to include that.\nTotally skip it and only include <code class=\"language-text\">me.cmd</code>. In my case, I wanted to be able to\nrun <code class=\"language-text\">:call ElixirLS.compile()</code> myself as well which will need to perform those\ntasks.</p>\n<p>The last argument <code class=\"language-text\">me</code> is a dictionary that contains the keys that point to\nfunctions that will accept a certain signature; the three functions it cares\nabout are:</p>\n<ul>\n<li><code class=\"language-text\">on_stdout(job_id, data, event)</code></li>\n<li><code class=\"language-text\">on_stderr(job_id, data, event)</code></li>\n<li><code class=\"language-text\">on_exit(job_id, exitcode, _event)</code></li>\n</ul>\n<p>The values that are passed into these functions are a bit odd, but remember it’s\nfocused on a stream of data, and not all the data at once. This means that the\ndata you get will be an array of values from the background job’s output (either\nstdout or stderr).</p>\n<p>Let’s look at one of the functions that receives the hook:</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">function ElixirLS.on_stdout(_job_id, data, _event)\n  let self.output[-1] .= a:data[0]\n  call extend(self.output, a:data[1:])\nendfunction</code></pre>\n      </div>\n<p><code class=\"language-text\">self</code> refers to the copy of the ElixirLS dictionary that started this job.\n(check out <code class=\"language-text\">:h self</code>). Before we started the job, we initialized the dictionary\nto have an <code class=\"language-text\">output</code> key that had a list with one empty string <code class=\"language-text\">[&#39;&#39;]</code>. We’re\ngoing to use this list and append all the incoming output into it. At the very\nend, <code class=\"language-text\">self.output</code> have something like <code class=\"language-text\">[&#39;hey&#39;, &#39;hi\\nthere&#39;, &quot;I&#39;m d&#39;, &#39;one\nnow&#39;]</code>. Since the data isn’t necessarily split at newlines, we’re going to\ncombine the last stored output’s with the first incoming element, and then add\nthe rest of the incoming data to the data.</p>\n<p><code class=\"language-text\">let self.output[-1] .= a:data[0]</code>. Take the last stored element and concat,\nconcat the first incoming data’s elemennt, and then assign it back to\n<code class=\"language-text\">self.output[-1]</code>. Then add the two lists together. <code class=\"language-text\">extend()</code> will mutate the\nfirst element.</p>\n<p>Since we want to treat <code class=\"language-text\">stderr</code> and <code class=\"language-text\">stdout</code> as the same kind of output, we’re\ngoing to have the <code class=\"language-text\">on_stderr</code> callback forward the call to the <code class=\"language-text\">on_stdout</code>\nfunction. This avoids duplicating the code.</p>\n<p>Finally, let’s look at the <code class=\"language-text\">on_exit</code> callback:</p>\n<div class=\"gatsby-highlight\" data-language=\"viml\">\n      <pre class=\"language-viml\"><code class=\"language-viml\">function ElixirLS.on_exit(_job_id, exitcode, _event)\n  if a:exitcode[0] == 0\n    echom &#39;&gt;&gt;&gt; ElixirLS compiled&#39;\n  else\n    echoerr join(self.output, &#39; &#39;)\n    echoerr &#39;&gt;&gt;&gt; ElixirLS compilation failed&#39;\n  endif\nendfunction</code></pre>\n      </div>\n<p>The exitcode is passed into this function, but it’s still the funky buffer-like\narray but it should always just be the one element with the exit code. If it’s\n0, then it exited ok without error so let’s echo a message indicating we’re\ndone.</p>\n<p>Otherwise, let’s echo out the entire output as an error that I can find with\n<code class=\"language-text\">:messages</code> and investigate what went wrong.</p>\n<p>All this means now is that we can run <code class=\"language-text\">:PlugUpdate</code> and ElixirLS will now update\nitself, ensuring it’s running on the best version of Elixir for itself,\neverything’s updated, downloaded, and recompiled without issue. I can also run\n<code class=\"language-text\">ElixirLS.compile()</code> at any time if I suspect I need to update ElixirLS.</p>\n<p>With nvim.coc I can also check <code class=\"language-text\">:CocInfo</code> to see if the language servers are\nrunning ok.</p>","frontmatter":{"title":"VIM ElixirLS and Updates","date":"March 03, 2020","tags":["elixir","vim"],"originalUrl":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/vim-elixir-ls-plug/","previous":{"fields":{"slug":"/blog/ecto_changeset_tips/"},"frontmatter":{"title":"Ecto Tips: UUID Boilerplate, Docs, and Composing Changesets","tags":["elixir","ecto"],"originalUrl":null,"excerpt":"There are some helpful techniques you can employ to help you and your\ncoworkers when writing long changeset functions. It's hard to remember what's\nrequired, optional, and defaulted. DB-generated UUIDs. And composing\nchangesets.\n"}},"next":null}}